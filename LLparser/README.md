# LL(1) 语法分析器实验报告

## 1. 功能描述
本实验实现了一个基于 **LL(1) 分析表** 的语法分析器。
能够对类 C 语言的简单子集进行语法分析，支持：
- 变量赋值
- `while` 循环
- `if-then-else` 条件语句
- 算术表达式与布尔表达式
- 复合语句块 `{ ... }`

分析器不仅能判断语法正确性，还能生成并输出 **语法分析树 (Parse Tree)**。

## 2. 输入输出
- **输入**: 词法分析后的记号流（或源代码，内部集成简易词法扫描）。
- **输出**:
    - 语法错误提示（如有）。
    - 控制台输出语法树结构的文本表示（缩进形式）。
    - `.dot` 文件，可用于生成可视化的语法树图片。


## 3. 数据结构
- **LL(1) 分析表**: `map<string, string> a[30]`，存储 `M[非终结符, 终结符] = 产生式`。
- **Trie 树**: 用于快速查找输入流中的关键字和运算符，实现简易词法分析。
- **推导序列**: `vector<pair<string, int>> llDerivationSeq`，记录生成语法树过程中的节点和深度。

## 4. 实现算法
采用 **表驱动的递归下降** 方式（混合模式）：
1. **预测分析**: 在 `solve` 函数中，根据当前非终结符 `cur` 和向前看符号（Lookahead），查询分析表 `a`。
2. **递归展开**:
    - 如果查表结果是非终结符，递归调用 `solve`。
    - 如果是终结符，与输入流进行匹配。
    - 如果是空产生式 `@`，直接返回。
3. **两遍扫描**:
    - 第一遍 (`error` 函数)：纯粹进行语法检查和错误恢复，不输出语法树。
    - 第二遍 (`solve` 函数)：在无重大错误前提下构建并输出语法树。

## 5. 错误处理
实现了 **恐慌模式 (Panic Mode)** 恢复机制：
- 当遇到无法匹配的符号时，跳过输入直到遇到 **同步符号** (如 `;`, `}`, `)` )。
- 引入了 `lastTokenLine` 机制，解决跨行错误（如缺少分号）导致的报错行号滞后问题，确保报错位置准确指向语句结束行。

## 6. 亮点概述
1. **Trie 树与 Hash 的双向映射架构**
   在符号管理中，利用 Trie 树（字典树）进行关键字和运算符的快速前缀匹配，同时结合 Hash Map 进行种别码映射。这种架构在 $O(L)$ 时间复杂度内完成 Token 识别，并支持单字符别名（如 `if` -> `y`）以优化内部查表效率。
   ```cpp
   // Trie 插入与查找
   void insert(string s) {
       int p = 0;
       for (int i = 0; i < s.length(); i++) {
           int c = s[i];
           if (!son[p][c]) son[p][c] = ++idx;
           p = son[p][c];
       }
       cnt[p] = 1; // 标记单词结束
   }
   ```

2. **预测分析表驱动与恐慌模式恢复**
   不同于简单的递归下降，本实现基于预计算的 LL(1) 预测分析表，消除了回溯开销。同时结合恐慌模式，当遇到语法错误时，通过跳过输入直到同步记号（Synchronizing Tokens）来实现鲁棒的错误恢复。
   ```cpp
   // 恐慌模式：跳过非法符号直到遇到同步集
   while (i < len && s[i] != ';' && s[i] != '}' && s[i] != ')') {
       if (s[i] == '\n') line++;
       i++;
   }
   // 报告错误（使用修正后的行号）
   cout << "语法错误，第" << reportLine << "行，缺少符号: '" << c << "'" << endl;
   ```

3. **AST 可视化集成**
   开发了独立的 `Visualizer` 模块，将解析过程中生成的推导序列转换为 Graphviz DOT 格式。这使得抽象的语法树能够以图形化方式直观展示，便于调试和理解语法结构。

   ```cpp
   // 导出 DOT 文件
   Visualizer::generateDOT("ll_tree.dot", llDerivationSeq);
   // 节点连接逻辑
   outfile << "    node" << parentIndex << " -> node" << i << ";" << endl;
   ```

4. **行号精确定位与空行容忍**
   在匹配过程中维护 `lastTokenLine`，记录上一次成功匹配的 Token 行号，当检测到缺少 `;` 等错误时，如果已经读入下一行的开头，则将报错行号回溯到 `lastTokenLine`，从而在存在空行或跨行语句时仍能精确定位到上一条语句的结束行。

## 7. 测试与验证

- 为 LL 分析器设计了包含正确样例和多类错误样例的测试集，如 `ll_test1.txt`、`ll_test2.txt`（语法正确）、`ll_error_test1.txt`、`ll_error_test2.txt`、`ll_error_test2_compact.txt`、`ll_error_test3.txt` 等。ll_error_test2的“含空行版”和“紧凑无空行版”用例用于验证在不同排版风格下，错误行号输出都与文件实际的出错行号一致（紧凑版在第4行，有空行版在第7行）。
- 对缺少 `;`、缺少 `)` 以及多种错误同时出现的情况进行了专门测试，以验证恐慌模式和行号追踪机制在连续错误场景下仍能给出稳定且不重复的错误提示。
