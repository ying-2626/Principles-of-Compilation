# LL(1) 语法分析器实验报告

## 1. 功能描述
本实验实现了一个基于 **LL(1) 分析表** 的语法分析器。
能够对类 C 语言的简单子集进行语法分析，支持：
- 变量赋值
- `while` 循环
- `if-then-else` 条件语句
- 算术表达式与布尔表达式
- 复合语句块 `{ ... }`

分析器不仅能判断语法正确性，还能生成并输出 **语法分析树 (Parse Tree)**。

## 2. 输入输出
- **输入**: 词法分析后的记号流（或源代码，内部集成简易词法扫描），实验中典型输入文件位于 `dataset/parser/ll` 目录，例如 `ll_test1.txt`、`ll_test2.txt`、`ll_error_test1.txt` 等。
- **输出**:
    - 语法错误提示（如有），默认打印到标准输出；通过 `run_tests.py` 运行时会被重定向到对应输入文件旁的 `*.out` 文件（例如 `dataset/parser/ll/ll_test1.txt.out`）。
    - 控制台输出的语法树结构文本表示（缩进形式，同样会写入 `.out` 文件中，便于对比不同测试用例）。
    - 语法树的 `.dot` 文件，默认名为 `ll_tree.dot`，在配合测试脚本运行时会被移动并重命名为与输入一一对应的 `*.dot`（例如 `dataset/parser/ll/ll_test1.txt.dot`），如果本机安装了 Graphviz，还会进一步生成同名 `.png` 图片。


## 3. 数据结构
- **LL(1) 分析表**: `map<string, string> a[30]`，存储 `M[非终结符, 终结符] = 产生式`。
- **Trie 树**: 用于快速查找输入流中的关键字和运算符，实现简易词法分析。
- **推导序列**: `vector<pair<string, int>> llDerivationSeq`，记录生成语法树过程中的节点和深度。

## 4. 实现算法
采用 **表驱动的递归下降** 方式（混合模式）：
1. **预测分析**: 在 `solve` 函数中，根据当前非终结符 `cur` 和向前看符号（Lookahead），查询分析表 `a`。
2. **递归展开**:
    - 如果查表结果是非终结符，递归调用 `solve`。
    - 如果是终结符，与输入流进行匹配。
    - 如果是空产生式 `@`，直接返回。
3. **两遍扫描**:
    - 第一遍 (`error` 函数)：纯粹进行语法检查和错误恢复，不输出语法树。
    - 第二遍 (`solve` 函数)：在无重大错误前提下构建并输出语法树。

## 5. 错误处理
实现了 **恐慌模式 (Panic Mode)** 恢复机制：
- 当遇到无法匹配的符号时，跳过输入直到遇到 **同步符号** (如 `;`, `}`, `)` )。
- 引入了 `lastTokenLine` 机制，解决跨行错误（如缺少分号）导致的报错行号滞后问题，确保报错位置准确指向语句结束行。

## 6. 亮点概述
1. **Trie 树与 Hash 的双向映射架构**
   在符号管理中，利用 Trie 树（字典树）进行关键字和运算符的快速前缀匹配，同时结合 Hash Map 进行种别码映射。这种架构在 $O(L)$ 时间复杂度内完成 Token 识别，并支持单字符别名（如 `if` -> `y`）以优化内部查表效率。与传统的“数组 + 线性扫描关键字表”或单纯依赖 Hash 对整串进行比较的方案相比，Trie 将共有前缀折叠在一起，减少了重复比较次数，而 Hash 则负责将内部编码映射回人类可读的关键字与运算符，实现了**查找性能**与**实现易用性**之间的平衡：既避免了巨大的多分支 `switch`，又能在多关键字场景下保持稳定的查询开销。
   ```cpp
   // Trie 插入与查找
   void insert(string s) {
       int p = 0;
       for (int i = 0; i < s.length(); i++) {
           int c = s[i];
           if (!son[p][c]) son[p][c] = ++idx;
           p = son[p][c];
       }
       cnt[p] = 1; // 标记单词结束
   }
   ```

2. **预测分析表驱动与恐慌模式恢复**
   不同于简单的递归下降，本实现基于预计算的 LL(1) 预测分析表，消除了回溯开销。同时结合恐慌模式，当遇到语法错误时，通过跳过输入直到同步记号（Synchronizing Tokens）来实现鲁棒的错误恢复。
   ```cpp
   // 恐慌模式：跳过非法符号直到遇到同步集
   while (i < len && s[i] != ';' && s[i] != '}' && s[i] != ')') {
       if (s[i] == '\n') line++;
       i++;
   }
   // 报告错误（使用修正后的行号）
   cout << "语法错误，第" << reportLine << "行，缺少符号: '" << c << "'" << endl;
   ```

3. **AST 可视化集成**
   开发了独立的 `Visualizer` 模块，将解析过程中生成的推导序列转换为 Graphviz DOT 格式。这使得抽象的语法树能够以图形化方式直观展示，便于调试和理解语法结构。

   ```cpp
   // 导出 DOT 文件
   Visualizer::generateDOT("ll_tree.dot", llDerivationSeq);
   // 节点连接逻辑
   outfile << "    node" << parentIndex << " -> node" << i << ";" << endl;
   ```

4. **行号精确定位与空行容忍**
   在匹配过程中维护 `lastTokenLine`，记录上一次成功匹配的 Token 行号，当检测到缺少 `;` 等错误时，如果已经读入下一行的开头，则将报错行号回溯到 `lastTokenLine`，从而在存在空行或跨行语句时仍能精确定位到上一条语句的结束行。
