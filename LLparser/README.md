# LL(1) 语法分析器实验报告

## 1. 功能描述
本实验实现了一个基于 **LL(1) 分析表** 的语法分析器。
能够对类 C 语言的简单子集进行语法分析，支持：
- 变量赋值
- `while` 循环
- `if-then-else` 条件语句
- 算术表达式与布尔表达式
- 复合语句块 `{ ... }`

分析器不仅能判断语法正确性，还能生成并输出 **语法分析树 (Parse Tree)**。

## 2. 输入输出
- **输入**: 词法分析后的记号流（或源代码，内部集成简易词法扫描）。
- **输出**:
    - 控制台输出语法树结构的文本表示（缩进形式）。
    - `.dot` 文件，可用于生成可视化的语法树图片。
    - 语法错误提示（如有）。

## 3. 数据结构
- **LL(1) 分析表**: `map<string, string> a[30]`，存储 `M[非终结符, 终结符] = 产生式`。
- **Trie 树**: 用于快速查找输入流中的关键字和运算符，实现简易词法分析。
- **推导序列**: `vector<pair<string, int>> llDerivationSeq`，记录生成语法树过程中的节点和深度。

## 4. 实现算法
采用 **表驱动的递归下降** 方式（混合模式）：
1. **预测分析**: 在 `solve` 函数中，根据当前非终结符 `cur` 和向前看符号（Lookahead），查询分析表 `a`。
2. **递归展开**:
    - 如果查表结果是非终结符，递归调用 `solve`。
    - 如果是终结符，与输入流进行匹配。
    - 如果是空产生式 `@`，直接返回。
3. **两遍扫描**:
    - 第一遍 (`error` 函数)：纯粹进行语法检查和错误恢复，不输出语法树。
    - 第二遍 (`solve` 函数)：在无重大错误前提下构建并输出语法树。

## 5. 错误处理
实现了 **恐慌模式 (Panic Mode)** 恢复机制：
- 当遇到无法匹配的符号时，跳过输入直到遇到 **同步符号** (如 `;`, `}`, `)` )。
- 引入了 `lastTokenLine` 机制，解决跨行错误（如缺少分号）导致的报错行号滞后问题，确保报错位置准确指向语句结束行。

**代码证据**:
```cpp
// 恐慌模式恢复
while (i < len && s[i] != ';' && s[i] != '}' && s[i] != ')')
{
    if (s[i] == '\n') line++;
    i++;
}
```

## 6. 亮点概述
- **准确的行号追踪**: 通过 `lastTokenLine` 记录上一个成功匹配的 Token 行号，解决了传统分析器在遇到空行时报错行号偏大的问题。
- **可视化支持**: 集成 `Visualizer` 类，自动生成 Graphviz DOT 文件，直观展示语法树结构。

**代码证据**:
```cpp
// 行号修正逻辑
if (line > lastTokenLine) {
    reportLine = lastTokenLine;
} else {
    reportLine = line;
}
```
