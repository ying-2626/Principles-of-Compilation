# 词法分析器实验报告

## 1. 功能描述
本实验实现了一个基于 **DFA (有限自动机)** 的 C 语言词法分析器。
能够识别并输出以下几类记号 (Token)：
- **关键字** (如 `int`, `float`, `if`, `while` 等)
- **标识符** (以字母或下划线开头)
- **数值常量** (整数、浮点数、科学计数法)
- **字符串常量** (如 `"hello"`)
- **字符常量** (如 `'a'`)
- **运算符与界符** (如 `+`, `==`, `{`, `;` 等)
- **注释** (单行 `//` 和多行 `/* ... */`)

## 2. 输入输出
- **输入**: C 语言源代码文件（实验中典型输入位于 `dataset/lexical` 目录，例如 `test1.c`、`error_test1.c`、`error_test2.c`）。
- **输出**: 记号序列，格式为 `<记号内容, 种别码>`，默认打印到标准输出；通过 `run_tests.py` 运行时，输出会被重定向为与输入同名的 `*.out` 文件（例如 `dataset/lexical/test1.c.out`）。

**示例输入**:
```c
int main() {
    float a = 1.5e-2;
    return 0;
}
```

**示例输出**:
```
1: <int,17>
2: <main,81>
3: <(,44>
4: <),45>
5: <{,59>
6: <float,13>
7: <a,81>
8: <=,72>
9: <1.5e-2,80>
10: <;,53>
...
```

## 3. 数据结构
- **DFA 状态转移表**: `int trans[MAX_STATES][ASCII_SIZE]`，存储状态转移逻辑。
- **状态接收表**: `int accept[MAX_STATES]`，标记每个状态是否为终态以及对应的 Token 类别。
- **关键字映射**: `map<string, int> keywords`，用于快速查找 Token 种别码。
- **运算符映射**: `map<string, int> operators`。

## 4. 实现算法
采用 **表驱动的 DFA 算法**：
1. **DFA 构建**: 在 `init_dfa()` 中通过代码硬编码构建 DFA 的状态和转移边。
    - 状态 0 为起始状态。
    - 分别构建了空白符、标识符、数字（含浮点/科学计数）、字符串、字符、注释、运算符的子自动机。
2. **最大匹配原则**:
    - 在 `Analysis()` 主循环中，从当前字符开始，尽可能长地运行 DFA，直到无法转移。
    - 记录最后经过的接收状态 (`last_accept_state`) 和位置。
    - 输出对应的 Token，并将扫描指针移动到该 Token 之后。

## 5. 错误处理
- 如果 DFA 在当前位置无法匹配任何有效的 Token（即 `last_accept_state` 为 -1），则跳过当前字符并继续尝试匹配，防止分析器卡死。

## 6. 亮点概述
1. **基于状态迁移的复杂 Token 识别**
   在处理数值常量时，完整的实现了整数、浮点数以及科学计数法的 DFA 状态链。例如，从整数状态遇到 `.` 进入小数部分，遇到 `e` 或 `E` 进入指数部分，并处理指数后的正负号。
   **代码证据**:
   ```cpp
   // 科学计数法状态构建
   int s_sci = dfa.add_state();
   dfa.add_transition(s_num, 'e', s_sci); // 整数 -> 科学计数
   dfa.add_transition(s_float, 'E', s_sci); // 浮点 -> 科学计数
   int s_sci_sign = dfa.add_state();
   dfa.add_transition(s_sci, '+', s_sci_sign); // 指数符号处理
   ```

2. **最长匹配策略 (Maximal Munch)**
   算法始终尝试匹配最长的合法 Token，有效区分了前缀重叠的运算符（如 `<` 与 `<<`，`=` 与 `==`）。
   **代码证据**:
   ```cpp
   while (pos < len) {
       // ... 尝试转移 ...
       if (accept[curr] != -1) {
           last_accept_state = curr;
           last_accept_pos = pos; // 贪婪记录最远的接收位置
       }
   }
   // 回退到最后一次成功接收的位置
   pos = last_accept_pos; 
   ```

3. **表驱动 DFA 与线性扫描实现的性能对比**
   词法分析核心采用二维数组形式的状态转移表 `trans[state][ch]` 和接收表 `accept[state]`，在匹配过程中只涉及常数次数组寻址与少量分支判断。相较于基于大量 `if-else`/`switch` 链或按正则表达式逐条线性尝试匹配的实现方式，表驱动 DFA 能够在 $O(n)$ 时间内完成整段源码扫描，且对每个字符的处理开销近似固定，更有利于 CPU 指令和缓存命中。配合关键字/运算符使用 `map` 做种别码映射，实现了在“实现复杂度”和“运行效率”之间较为均衡的折中：既避免了过于晦涩的手写状态机，又比简单串匹配方案具有更好的可扩展性和性能上限。
