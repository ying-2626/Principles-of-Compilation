# 词法分析器实验报告

## 1. 功能描述
本实验实现了一个基于 **DFA (有限自动机)** 的 C 语言词法分析器。
能够识别并输出以下几类记号 (Token)：
- **关键字** (如 `int`, `float`, `if`, `while` 等)
- **标识符** (以字母或下划线开头)
- **数值常量** (整数、浮点数、科学计数法)
- **字符串常量** (如 `"hello"`)
- **字符常量** (如 `'a'`)
- **运算符与界符** (如 `+`, `==`, `{`, `;` 等)
- **注释** (单行 `//` 和多行 `/* ... */`)

## 2. 输入输出
- **输入**: C 语言源代码文件。
- **输出**: 记号序列，格式为 `<记号内容, 种别码>`。

**示例输入**:
```c
int main() {
    float a = 1.5;
    return 0;
}
```

**示例输出**:
```
1: <int,17>
2: <main,81>
3: <(,44>
4: <),45>
5: <{,59>
6: <float,13>
7: <a,81>
8: <=,72>
9: <1.5,80>
10: <;,53>
...
```

## 3. 数据结构
- **DFA 状态转移表**: `int trans[MAX_STATES][ASCII_SIZE]`，存储状态转移逻辑。
- **状态接收表**: `int accept[MAX_STATES]`，标记每个状态是否为终态以及对应的 Token 类别。
- **关键字映射**: `map<string, int> keywords`，用于快速查找 Token 种别码。
- **运算符映射**: `map<string, int> operators`。

## 4. 实现算法
采用 **表驱动的 DFA 算法**：
1. **DFA 构建**: 在 `init_dfa()` 中通过代码硬编码构建 DFA 的状态和转移边。
    - 状态 0 为起始状态。
    - 分别构建了空白符、标识符、数字（含浮点/科学计数）、字符串、字符、注释、运算符的子自动机。
2. **最大匹配原则**:
    - 在 `Analysis()` 主循环中，从当前字符开始，尽可能长地运行 DFA，直到无法转移。
    - 记录最后经过的接收状态 (`last_accept_state`) 和位置。
    - 输出对应的 Token，并将扫描指针移动到该 Token 之后。

## 5. 错误处理
- 如果 DFA 在当前位置无法匹配任何有效的 Token（即 `last_accept_state` 为 -1），则跳过当前字符并继续尝试匹配，防止分析器卡死。

## 6. 亮点概述
- **完整的 DFA 构建**: 支持复杂的词法特性，如科学计数法 (`1.2e-3`) 和转义字符。
- **基于 Trie 思想的运算符匹配**: 在 DFA 中为所有运算符构建了类似 Trie 的路径，能够自动处理最长匹配（如区分 `<` 和 `<<`）。

**代码证据**:
```cpp
// 科学计数法状态构建
int s_sci = dfa.add_state();
dfa.add_transition(s_num, 'e', s_sci);
dfa.add_transition(s_float, 'E', s_sci);
// ...
```
