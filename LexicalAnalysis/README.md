# 词法分析器实验报告

## 1. 功能描述
本实验实现了一个基于 **DFA (有限自动机)** 的 C 语言词法分析器。
能够识别并输出以下几类记号 (Token)：
- **关键字** (如 `int`, `float`, `if`, `while` 等)
- **标识符** (以字母或下划线开头)
- **数值常量** (整数、浮点数、科学计数法)
- **字符串常量** (如 `"hello"`)
- **字符常量** (如 `'a'`)
- **运算符与界符** (如 `+`, `==`, `{`, `;` 等)
- **注释** (单行 `//` 和多行 `/* ... */`)

## 2. 输入输出
- **输入**: C 语言源代码文件。
- **输出**: 记号序列，格式为 `<记号内容, 种别码>`。

**示例输入**:
```c
int main() {
    float a = 1.5e-2;
    return 0;
}
```

**示例输出**:
```
1: <int,17>
2: <main,81>
3: <(,44>
4: <),45>
5: <{,59>
6: <float,13>
7: <a,81>
8: <=,72>
9: <1.5e-2,80>
10: <;,53>
...
```

## 3. 数据结构
- **DFA 状态转移表**: `int trans[MAX_STATES][ASCII_SIZE]`，存储状态转移逻辑。
- **状态接收表**: `int accept[MAX_STATES]`，标记每个状态是否为终态以及对应的 Token 类别。
- **关键字映射**: `map<string, int> keywords`，用于快速查找 Token 种别码。
- **运算符映射**: `map<string, int> operators`。

## 4. 实现算法
采用 **表驱动的 DFA 算法**：
1. **DFA 构建**: 在 `init_dfa()` 中通过代码硬编码构建 DFA 的状态和转移边。
    - 状态 0 为起始状态。
    - 分别构建了空白符、标识符、数字（含浮点/科学计数）、字符串、字符、注释、运算符的子自动机。
2. **最大匹配原则**:
    - 在 `Analysis()` 主循环中，从当前字符开始，尽可能长地运行 DFA，直到无法转移。
    - 记录最后经过的接收状态 (`last_accept_state`) 和位置。
    - 输出对应的 Token，并将扫描指针移动到该 Token 之后。

## 5. 错误处理
- 如果 DFA 在当前位置无法匹配任何有效的 Token（即 `last_accept_state` 为 -1），则跳过当前字符并继续尝试匹配，防止分析器卡死。

## 6. 亮点概述
1. **基于状态迁移的复杂 Token 识别**
   在处理数值常量时，完整的实现了整数、浮点数以及科学计数法的 DFA 状态链。例如，从整数状态遇到 `.` 进入小数部分，遇到 `e` 或 `E` 进入指数部分，并处理指数后的正负号。
   **代码证据**:
   ```cpp
   // 科学计数法状态构建
   int s_sci = dfa.add_state();
   dfa.add_transition(s_num, 'e', s_sci); // 整数 -> 科学计数
   dfa.add_transition(s_float, 'E', s_sci); // 浮点 -> 科学计数
   int s_sci_sign = dfa.add_state();
   dfa.add_transition(s_sci, '+', s_sci_sign); // 指数符号处理
   ```

2. **最长匹配策略 (Maximal Munch)**
   算法始终尝试匹配最长的合法 Token，有效区分了前缀重叠的运算符（如 `<` 与 `<<`，`=` 与 `==`）。
   **代码证据**:
   ```cpp
   while (pos < len) {
       // ... 尝试转移 ...
       if (accept[curr] != -1) {
           last_accept_state = curr;
           last_accept_pos = pos; // 贪婪记录最远的接收位置
       }
   }
   // 回退到最后一次成功接收的位置
   pos = last_accept_pos; 
   ```
