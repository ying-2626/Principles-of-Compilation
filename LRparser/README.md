# LR(1) 语法分析器实验报告

## 1. 功能描述
本实验实现了一个基于 **LR 分析表** (实际上是 SLR 或 LALR，取决于生成的表) 的语法分析器。
支持与 LL 分析器相同的文法子集（赋值、循环、条件、块结构），但采用自底向上的分析方式。

## 2. 输入输出
- **输入**: 源代码。
- **输出**:
    - 移进-规约过程的日志。
    - 语法树的可视化 `.dot` 文件。
    - 精确的错误报告。

## 3. 数据结构
- **ACTION 表**: `struct Action { int type; int val; }`，二维数组，存储移进、规约、接受动作。
- **GOTO 表**: 二维数组，存储非终结符的状态转移。
- **状态栈**: `stack<int> stateStack`，维护自动机状态。
- **节点栈**: `stack<ASTNode *> nodeStack`，用于在规约时构建语法树节点。

## 4. 实现算法
采用 **移进-规约 (Shift-Reduce) 分析算法**：
1. **主循环**: 根据栈顶状态和当前向前看符号查 `ACTION` 表。
2. **移进 (Shift)**: 将新状态压栈，创建终结符叶节点压入节点栈，消费输入。
3. **规约 (Reduce)**:
    - 弹出 `|右部|` 个状态和节点。
    - 创建新的非终结符父节点，将其子节点指向弹出的节点。
    - 查 `GOTO` 表压入新状态。
4. **接受 (Accept)**: 分析成功结束。

## 5. 错误处理
实现了 **虚拟插入 (Virtual Insertion)** 与 **恐慌模式** 结合的策略：
1. **虚拟插入**: 当查表失败（报错）时，尝试在输入流前“假想”插入常见的缺失符号（如 `;`, `)`, `]`, `}`）。
    - 优先尝试插入闭括号 `)`，以解决 `while(...)` 结构中常见的误报问题。
    - 如果插入后能查到有效动作，则执行该动作并报错，但不消耗实际输入。
2. **恐慌模式**: 如果虚拟插入失败，则跳过当前非法 Token。
3. **行号修正**: 同样引入 `lastAcceptedTokenLine`，确保报错行号准确对应上一个有效 Token。

**代码证据**:
```cpp
// 虚拟插入优先级调整
char candidates[] = {')', ']', '}', ';'}; // 优先尝试闭括号
for (char c : candidates) {
    Action recAct = ACTION[currentState][(unsigned char)c];
    if (recAct.type != error) { ... }
}
```

## 6. 亮点概述
- **自动错误修复尝试**: 通过虚拟插入机制，能够从常见的语法错误（如漏写分号或括号）中自动恢复，并继续分析后续代码，而不是直接退出。
- **稳健的错误定位**: 结合 `lastAcceptedTokenLine` 和优先级调整，极大地减少了误报（如将缺 `)` 误报为缺 `;`）和行号偏移。

